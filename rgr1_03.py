import math
import itertools
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
import random # Добавлен импорт для генерации случайных точек
import tkinter as tk # Импорт для messagebox
from tkinter import messagebox # Импорт для messagebox

# --- Геометрические вспомогательные функции ---

def cross_product(p1, p2, p3):
    """
    Вычисляет векторное произведение (p2-p1) x (p3-p1).
    Знак результата указывает на ориентацию точки p3 относительно вектора p1->p2.
    - Если результат > 0, то p3 находится слева от вектора p1->p2 (поворот против часовой стрелки).
    - Если результат < 0, то p3 находится справа от вектора p1->p2 (поворот по часовой стрелке).
    - Если результат = 0, то точки p1, p2, p3 коллинеарны.
    """
    return (p2[0] - p1[0]) * (p3[1] - p1[1]) - \
           (p2[1] - p1[1]) * (p3[0] - p1[0])

def distance_sq(p1, p2):
    """
    Вычисляет квадрат евклидова расстояния между двумя точками p1 и p2.
    Использование квадрата расстояния позволяет избежать вызова math.sqrt,
    что может быть полезно для сравнения расстояний.
    """
    return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2

def convex_hull_graham_scan(points):
    """
    Строит минимальную выпуклую оболочку для набора точек с помощью алгоритма сканирования Грэхема.
    Алгоритм работает следующим образом:
    1. Находит опорную точку p0 (самую нижнюю, затем самую левую).
    2. Сортирует остальные точки по полярному углу относительно p0.
       Если углы равны, берется точка, наиболее удаленная от p0 (или ближайшая, в зависимости от реализации).
       Данная реализация сортирует по углу, затем по расстоянию (ближайшая первая).
    3. Инициализирует стек hull первыми двумя точками (p0 и первая отсортированная).
    4. Итерирует по оставшимся отсортированным точкам:
       - Пока в стеке hull >= 2 точек и последняя точка, предпоследняя точка и текущая точка
         образуют "не левый" поворот (т.е. правый или коллинеарный), удаляет последнюю точку из стека.
       - Добавляет текущую точку в стек.
    В результате в стеке остаются вершины выпуклой оболочки в порядке против часовой стрелки.
    """
    if len(points) < 3:
        # Недостаточно точек для формирования многоугольника.
        # Возвращаем отсортированные точки, чтобы избежать ошибок при попытке доступа к элементам.
        return sorted(points, key=lambda p: (p[0], p[1]))

    # 1. Найти опорную точку p0 (самая нижняя, затем самая левая).
    p0 = min(points, key=lambda p: (p[1], p[0]))
    
    # 2. Отсортировать остальные точки по полярному углу относительно p0.
    # Точки, не совпадающие с p0
    other_points = [p for p in points if p != p0]
    
    # Ключ сортировки: сначала по полярному углу, затем по расстоянию от p0.
    # math.atan2(y, x) возвращает арктангенс y/x в радианах, в диапазоне [-pi, pi].
    def angle_sort_key(point):
        angle = math.atan2(point[1] - p0[1], point[0] - p0[0])
        # Для коллинеарных точек, более близкая точка должна идти первой,
        # чтобы дальняя точка могла ее "перекрыть" при необходимости в основном цикле.
        return (angle, distance_sq(p0, point))

    sorted_angular_points = sorted(other_points, key=angle_sort_key)

    if not sorted_angular_points: # Если только одна точка p0 или все точки совпадают с p0
        return [p0] # Оболочка состоит из одной точки

    # 3. Инициализируем стек hull первыми двумя точками
    # (p0 и первая точка из отсортированного списка).
    hull = [p0, sorted_angular_points[0]]

    # 4. Итерируем по оставшимся отсортированным точкам
    for i in range(1, len(sorted_angular_points)):
        pt = sorted_angular_points[i]
        # Пока в стеке hull >= 2 точек и последняя точка, предпоследняя точка и текущая точка (pt)
        # образуют "не левый" поворот (т.е. правый или коллинеарный), удаляем последнюю точку из стека.
        # cross_product(hull[-2], hull[-1], pt) <= 0 означает правый поворот или коллинеарность.
        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], pt) <= 0:
            hull.pop() # Удаляем последнюю точку из стека
        hull.append(pt) # Добавляем текущую точку в стек
    
    return hull


def polygon_area(vertices):
    """
    Вычисляет площадь многоугольника по формуле шнурков (Shoelace formula).
    Вершины многоугольника должны быть упорядочены (по или против часовой стрелки).
    Формула: Area = 0.5 * |(x1y2 + x2y3 + ... + xny1) - (y1x2 + y2x3 + ... + ynx1)|
    """
    n = len(vertices)
    if n < 3:
        return 0.0  # Не многоугольник
    
    area = 0.0
    for i in range(n):
        j = (i + 1) % n  # Следующая вершина, замыкающаяся на первую (индекс j будет 0 для последней i)
        area += vertices[i][0] * vertices[j][1]
        area -= vertices[j][0] * vertices[i][1]
    return abs(area) / 2.0

def is_inside_convex_polygon(point, polygon_vertices):
    """
    Проверяет, находится ли точка `point` внутри или на границе выпуклого многоугольника `polygon_vertices`.
    Для выпуклого многоугольника, вершины которого упорядочены (например, против часовой стрелки),
    точка находится внутри (или на границе), если она лежит с одной и той же стороны (или на линии)
    относительно всех ребер многоугольника.
    Это проверяется с помощью знака векторного произведения.
    """
    n = len(polygon_vertices)
    if n < 3:
        return False # Не многоугольник

    # Ожидаемый знак векторного произведения (1 для левого поворота, -1 для правого).
    # Если вершины упорядочены против часовой стрелки, точка должна быть слева от каждого ребра (или на нем).
    expected_sign = 0 
    epsilon = 1e-9 # Малая величина для сравнения с нулем из-за погрешностей float

    for i in range(n):
        p1 = polygon_vertices[i]
        p2 = polygon_vertices[(i + 1) % n] # Следующая вершина
        
        cp = cross_product(p1, p2, point) # Векторное произведение для ребра (p1,p2) и точки
        
        current_sign = 0
        if cp > epsilon: # Точка слева от ребра
            current_sign = 1
        elif cp < -epsilon: # Точка справа от ребра
            current_sign = -1
        # else current_sign = 0 (точка коллинеарна ребру)

        if current_sign == 0: # Точка коллинеарна ребру (p1, p2)
            # Необходимо проверить, лежит ли точка на отрезке [p1, p2].
            # Если точка коллинеарна, но вне отрезка, она считается снаружи.
            min_x, max_x = min(p1[0], p2[0]), max(p1[0], p2[0])
            min_y, max_y = min(p1[1], p2[1]), max(p1[1], p2[1])
            # Проверяем, что координаты точки находятся в пределах прямоугольника, описывающего отрезок.
            if not (min_x - epsilon <= point[0] <= max_x + epsilon and \
                    min_y - epsilon <= point[1] <= max_y + epsilon):
                return False # Точка коллинеарна, но вне отрезка ребра
            continue # Точка на отрезке ребра, продолжаем проверку с другими ребрами

        if expected_sign == 0: # Первое ребро, для которого точка не коллинеарна
            expected_sign = current_sign
        elif expected_sign != current_sign:
            # Если знак изменился, точка находится с другой стороны от какого-то ребра,
            # следовательно, она снаружи многоугольника.
            return False 
            
    # Если все проверки пройдены, точка находится внутри или на границе.
    # Если expected_sign остался 0 (все точки коллинеарны всем ребрам),
    # это может означать, что многоугольник вырожден в линию, и точка на этой линии,
    # или точка является одной из вершин. В таких случаях считаем ее "внутри".
    return True

# --- Новая функция для генерации случайных точек ---
def generate_random_points(num_points, min_coord, max_coord):
    points = []
    for _ in range(num_points):
        x = random.randint(min_coord, max_coord)
        y = random.randint(min_coord, max_coord)
        points.append((x, y))
    return points

# --- Новая функция для отображения информации в messagebox ---
def show_message_box(title, message):
    """
    Отображает информационное сообщение в окне messagebox.
    """
    root = tk.Tk()
    root.withdraw()  # Скрываем основное окно Tkinter
    messagebox.showinfo(title, message)
    root.destroy() # Уничтожаем окно после закрытия messagebox

# --- Основная логика ---

def find_min_area_covering_quadrilateral(set1, set2, output_messages_list):
    """
    Находит 4 различные точки из множества `set1`, которые образуют выпуклый четырехугольник
    минимальной площади, покрывающий все точки из множества `set2`.
    Добавляет информацию о процессе в output_messages_list и выводит в консоль.
    Возвращает:
    - optimal_quad_vertices (list of tuples): Список вершин найденного оптимального четырехугольника.
                                            None, если такой четырехугольник не найден.
    - min_area (float): Минимальная площадь. float('inf'), если четырехугольник не найден.
    """
    min_area = float('inf') # Инициализируем минимальную площадь очень большим значением
    optimal_quad_vertices = None # Здесь будут храниться вершины лучшего найденного четырехугольника

    # Проверка, достаточно ли точек в set1 для формирования четырехугольника
    if len(set1) < 4:
        msg = "Предупреждение: В Множестве 1 менее 4 точек. Невозможно сформировать четырехугольник."
        print(msg)
        output_messages_list.append(msg)
        return None, float('inf')

    # 1. Перебираем все возможные комбинации из 4 различных точек из set1
    # itertools.combinations генерирует все уникальные сочетания без повторений.
    for p_combination in itertools.combinations(set1, 4):
        # p_combination - это кортеж из 4 выбранных точек, например, ((x1,y1), (x2,y2), (x3,y3), (x4,y4))
        current_points_list = list(p_combination) # Преобразуем в список для удобства
        
        # 2. Для каждой комбинации строим выпуклую оболочку.
        # Это упорядочит вершины и позволит проверить, образуют ли они выпуклый четырехугольник.
        hull_vertices = convex_hull_graham_scan(current_points_list)

        # 3. Убеждаемся, что выпуклая оболочка этих 4 точек является четырехугольником.
        # То есть, все 4 точки являются вершинами своей выпуклой оболочки.
        # Если, например, одна точка лежит внутри треугольника, образованного тремя другими,
        # то выпуклая оболочка будет треугольником (3 вершины).
        if len(hull_vertices) != 4:
            continue # Эта комбинация не образует выпуклый четырехугольник, переходим к следующей

        # 4. Вычисляем площадь полученного четырехугольника
        current_area = polygon_area(hull_vertices)

        # 5. Проверяем, покрывает ли этот четырехугольник все точки из set2
        all_points_in_set2_covered = True
        if not set2: # Если set2 пуст, условие покрытия считается выполненным
            pass
        else:
            for point_s2 in set2:
                if not is_inside_convex_polygon(point_s2, hull_vertices):
                    all_points_in_set2_covered = False # Найдена точка из set2, которая не покрыта
                    break # Нет смысла проверять остальные точки из set2 для этого четырехугольника
        
        # 6. Если все точки из set2 покрыты и площадь текущего четырехугольника меньше минимальной найденной,
        # то обновляем результат.
        if all_points_in_set2_covered:
            if current_area < min_area:
                min_area = current_area
                optimal_quad_vertices = hull_vertices
                
    return optimal_quad_vertices, min_area

# --- Данные и выполнение ---

if __name__ == '__main__':
    # Этот блок выполняется только при запуске скрипта напрямую (не при импорте как модуля)

    output_messages = [] # Список для сбора сообщений для вывода в messagebox

    # --- Выбор источника данных ---
    USE_RANDOM_POINTS = True  # Установите True для генерации случайных точек
    # USE_RANDOM_POINTS = False # Установите False для использования предопределенных наборов

    if USE_RANDOM_POINTS:
        # Параметры для генерации случайных точек
        num_set1_points = random.randint(10, 20) # Случайное количество точек для Множества 1 (от 10 до 20)
        num_set2_points = 1 #random.randint(3, 10)  # Случайное количество точек для Множества 2 (от 3 до 10)
        coord_min = 0    # Минимальное значение координаты
        coord_max = 100  # Максимальное значение координаты
        
        # Генерируем случайные точки
        set1_points = generate_random_points(num_set1_points, coord_min, coord_max)
        set2_points = generate_random_points(num_set2_points, coord_min, coord_max)
        
        msg1 = f"Сгенерировано {len(set1_points)} случайных точек для Множества 1."
        msg2 = f"Сгенерировано {len(set2_points)} случайных точек для Множества 2."
        print(msg1)
        print(msg2)
        output_messages.append(msg1)
        output_messages.append(msg2)
    else:
        # --- Используем предопределенные наборы точек ---
        msg = "Используются предопределенные наборы точек."
        print(msg)
        output_messages.append(msg)
        
        # Пример 1 (основной, должен найти решение)
        set1_points = [
            (0, 0), (10, 0), (10, 10), (0, 10),  # Вершины большого квадрата
            (1, 5), (5, 1), (9, 5), (5, 9),      # Внутренние точки для выбора
            (2,2), (8,2), (8,8), (2,8)           # Еще точки для выбора
        ]
        set2_points = [
            (3, 3), (7, 7), (4, 6), (6, 4)       # Точки, которые нужно покрыть
        ]

        # # Пример 2 (другой набор, также должен найти решение)
        # set1_points = [(0,0), (1,3), (4,4), (5,1), (2,-1), (3,0)]
        # set2_points = [(2,2), (3,1)]

        # # Пример 3 (нет решения, точки set2 далеко)
        # set1_points = [(0,0), (1,0), (0,1), (1,1)] # Маленький квадрат
        # set2_points = [(5,5)] # Точка далеко за пределами

        # # Пример 4 (мало точек в set1 для формирования четырехугольника)
        # set1_points = [(0,0), (1,0), (0,1)] # Всего 3 точки
        # set2_points = [(0.5,0.5)]


    # Вызов основной функции для поиска четырехугольника
    optimal_quad, min_area_val = find_min_area_covering_quadrilateral(set1_points, set2_points, output_messages)

    # Добавляем информацию о результате поиска в список сообщений и выводим в консоль
    if optimal_quad:
        msg_res1 = f"Найден оптимальный четырехугольник с вершинами: {optimal_quad}"
        msg_res2 = f"Минимальная площадь: {min_area_val:.2f}"
        print(msg_res1)
        print(msg_res2)
        output_messages.append(msg_res1)
        output_messages.append(msg_res2)
    else:
        msg_no_res = "Не удалось найти четырехугольник, удовлетворяющий условиям."
        print(msg_no_res)
        output_messages.append(msg_no_res)

    # Формируем итоговое сообщение из списка
    final_message_for_box = "\n".join(output_messages)

    # Отображаем messagebox с результатами ПЕРЕД показом графика
    show_message_box("Результаты обработки", final_message_for_box)

    # --- Графическое представление результатов ---
    plt.figure(figsize=(10, 10)) # Задаем размер окна для графика

    # Отобразить точки из Множества 1
    if set1_points:
        s1_x, s1_y = zip(*set1_points) # Разделяем координаты x и y
        plt.scatter(s1_x, s1_y, c='blue', marker='o', label='Множество 1', s=50, zorder=2)

    # Отобразить точки из Множества 2
    if set2_points:
        s2_x, s2_y = zip(*set2_points) # Разделяем координаты x и y
        plt.scatter(s2_x, s2_y, c='red', marker='x', label='Множество 2', s=70, zorder=3)

    # Отобразить найденный оптимальный четырехугольник
    if optimal_quad:
        # Создаем объект многоугольника для отображения
        polygon_patch = Polygon(optimal_quad, closed=True, edgecolor='green', facecolor='lightgreen', alpha=0.5, linewidth=2, zorder=1)
        plt.gca().add_patch(polygon_patch) # Добавляем многоугольник на график
        
        # Аннотации для вершин четырехугольника (подписываем вершины)
        for i, (x, y) in enumerate(optimal_quad):
            plt.annotate(f"V{i+1}\n({x},{y})", (x, y), textcoords="offset points", xytext=(5,5), ha='left', fontsize=8)

    # Настройка графика
    plt.xlabel("X координата") # Подпись оси X
    plt.ylabel("Y координата") # Подпись оси Y
    plt.title("Минимальный покрывающий четырехугольник") # Заголовок графика
    plt.legend() # Показать легенду (описания для Множества 1 и Множества 2)
    plt.grid(True) # Включить сетку
    plt.axis('equal') # Установить одинаковый масштаб по осям X и Y для корректного отображения геометрии
    plt.tight_layout() # Автоматически корректирует параметры графика для плотного размещения
    plt.show() # Показать график
